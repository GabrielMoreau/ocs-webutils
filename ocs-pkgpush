#!/bin/bash
#
# ocs-pkgpush
#
# License GNU GPL version 2
# Copyright (C) 2025, LEGI UMR 5519 / CNRS UGA G-INP, Grenoble, France
#
# 2025/08/07 Gabriel Moreau <Gabriel.Moreau@univ-grenoble-alpes.fr>

# üì¶ Preparing the virtual environment
CACHE_DIR="${XDG_CACHE_HOME:-$HOME/.cache}"
if [ ! -e "$CACHE_DIR/ocs-utils/venv/bin/activate" ] || [ ! -e "$CACHE_DIR/ocs-utils/venv/bin/playwright" ]
then
    (
        mkdir -p "$CACHE_DIR/ocs-utils"
        cat <<'END_REQUIRE' > "$CACHE_DIR/ocs-utils/requirements.txt"
playwright
secretstorage
END_REQUIRE
        python3 -m venv "$CACHE_DIR/ocs-utils/venv"
        source "$CACHE_DIR/ocs-utils/venv/bin/activate"
        pip install --upgrade -r "$CACHE_DIR/ocs-utils/requirements.txt"
        playwright install
    )
fi

# üîπ Activate the venv
source "$CACHE_DIR/ocs-utils/venv/bin/activate"

# üêç Inline Python script
exec python3 - "$@" <<'END_PYTHON'
import os
import sys
import argparse
import getpass
import asyncio
import secretstorage
from pathlib import Path
from playwright.async_api import async_playwright
from playwright._impl._errors import TimeoutError as PlaywrightTimeoutError, Error as PlaywrightError

__version__ = "0.8.3"

cache_dir = os.getenv("XDG_CACHE_HOME") or os.path.expanduser("~/.cache")
SESSION_FILE = os.path.join(cache_dir, "ocs-utils", "session_state.json")

def prompt_from_tty(prompt, hide=False):
    """Prompt for input from the terminal, even if stdin is non-interactive."""
    with open("/dev/tty", "r") as tty_in, open("/dev/tty", "w") as tty_out:
        if hide:
            import getpass
            return getpass.getpass(prompt, stream=tty_out)
        else:
            tty_out.write(prompt)
            tty_out.flush()
            return tty_in.readline().strip()

def try_get_credentials_from_secretstorage(url: str):
    """
    Attempt to retrieve username/password over SercretStorage (Gnome Keyring or KeePassXC).
    Returns (None, None) if unsuccessful.
    """

    bus = secretstorage.dbus_init()
    for collection in secretstorage.get_all_collections(bus):
        if collection.is_locked():
            try:
                collection.unlock()
            except Exception:
                continue  # on ignore les collections non accessibles
        #print("NAME: ", collection.get_label())

        items = list(collection.search_items({"URL": url}))
        if not items:
            continue

        for item in items:
            attrs = item.get_attributes()
            #print("ATTR: ", attrs)
            username = attrs.get("UserName") or item.get_label()

            # Try get_secret()
            password = None
            try:
                raw_secret = item.get_secret()
                if raw_secret:
                    password = raw_secret.decode()
            except Exception:
                pass  # KeePassXC error here

            # Fallback : attribut ocs-pkgpush
            if not password:
                password = attrs.get("ocs-utils-code")

            # Next item
            if not password:
                continue

            return username, password

    # rien trouv√© dans aucune collection
    return None, None

async def safe_goto(page, url, timeout=30000):
    """
    Attempt to navigate to the URL and return:
    - True if OK
    - False if network error or timeout
    """
    try:
        await page.goto(url, timeout=timeout)
        return True
    except PlaywrightTimeoutError:
        print(f"‚ùå Unable to access {url} (timeout exceeded).")
        print("üí° Check your network connection or VPN.")
        return False
    except PlaywrightError as e:
        print(f"‚ùå Error accessing {url}: {e}")
        print("üí° Check if the server is reachable and if VPN is active.")
        return False

async def session_is_valid(url):
    """
    Check if the saved session is still valid.
    Returns:
      - True  => session valid
      - False => session saved but invalid (login form present)
      - None  => server unreachable / network error
    """
    if not os.path.exists(SESSION_FILE):
        return False

    async with async_playwright() as p:
        browser = await p.chromium.launch(headless=True, args=["--ignore-certificate-errors"])
        context = await browser.new_context(storage_state=SESSION_FILE, ignore_https_errors=True)
        page = await context.new_page()

        if not await safe_goto(page, f"{url}/?function=tele_build", timeout=15000):
            await browser.close()
            return None  # server unreachable

        valid = not await page.locator('input[name="LOGIN"]').is_visible()
        await browser.close()
        return valid

async def main():
    parser = argparse.ArgumentParser(prog="ocs-pkgpush", description="Push a package to OCS Inventory")
    parser.add_argument("--url", required=True, help="OCS Inventory URL (e.g. https://server/ocsreports)")
    parser.add_argument("--username", help="OCS username (optional if session is valid)")
    parser.add_argument("--password", help="OCS password (optional if session is valid)")
    parser.add_argument("--name", required=True, help="Package name")
    parser.add_argument("--description", required=True, help="Package description")
    parser.add_argument("--priority", type=int, default=5, help="Package priority (default is 5)")
    parser.add_argument("--file", required=True, help="Path to the file to upload")
    parser.add_argument("--timeout", type=int, default=300, help="Timeout when uploading file package (defaut to 300 secondes / 5 min)")
    parser.add_argument("--notify", choices=["YES", "NO"], default="YES", help="Notify user or not (default is YES)")
    parser.add_argument("--notif-text", default="Install or update package", help="Notification text")
    parser.add_argument("--notif-duration", type=int, default=5, help="Notification duration (default is 5 seconds)")
    parser.add_argument("--can-cancel", choices=["YES", "NO"], default="NO", help="User can cancel action (default is NO)")
    parser.add_argument("--can-report", choices=["YES", "NO"], default="YES", help="User can report action for the next time (default is YES)")
    parser.add_argument("--headless", action="store_true", help="Run without GUI")
    parser.add_argument("--capture-dir", help="Directory to save screenshots (optional)")
    args = parser.parse_args()

    # Check if the file to upload exists
    if not os.path.isfile(args.file):
        print(f"‚ùå Error: file '{args.file}' not found.")
        sys.exit(1)

    # Prepare capture directory if requested
    capture_dir = None
    if args.capture_dir:
        capture_dir = Path(args.capture_dir)
        capture_dir.mkdir(parents=True, exist_ok=True)

    async def capture(page, filename):
        if capture_dir:
            path = capture_dir / filename
            await page.screenshot(path=str(path))
            print(f"üì∏ Screenshot saved: {path}")

    valid_state = await session_is_valid(args.url)

    async with async_playwright() as p:
        browser = await p.chromium.launch(headless=args.headless, args=["--ignore-certificate-errors"])
        if valid_state is None:
            # Network/server problem detected while checking session ‚Üí abort early
            await browser.close()
            sys.exit(1)
        elif valid_state is True:
            print("‚ôªÔ∏è  Existing valid session ‚Üí reusing")
            context = await browser.new_context(storage_state=SESSION_FILE, ignore_https_errors=True)
            page = await context.new_page()
        else:
            print("üîê Invalid or missing session ‚Üí login required")
            user_ss, pwd_ss = try_get_credentials_from_secretstorage(args.url)
            if user_ss and pwd_ss:
                print("‚úÖ Credentials retrieved via SecretStorage (Gnome Keyring or KeePassXC)")
                args.username = user_ss
                args.password = pwd_ss
            else:
                if not args.username:
                    args.username = prompt_from_tty("OCS username: ")
                if not args.password:
                    args.password = prompt_from_tty("OCS password: ", hide=True)

            context = await browser.new_context(ignore_https_errors=True)
            page = await context.new_page()
            if not await safe_goto(page, args.url):
                await browser.close()
                sys.exit(1)
            await page.fill('input[name="LOGIN"]', args.username)
            await page.fill('input[name="PASSWD"]', args.password)
            await page.click('input[name="Valid_CNX"]')
            await page.wait_for_load_state('networkidle')

            if await page.locator('input[name="LOGIN"]').is_visible():
                print("‚ùå Login failed")
                await browser.close()
                sys.exit(1)

            # Save session state
            os.makedirs(os.path.dirname(SESSION_FILE), exist_ok=True)
            await context.storage_state(path=SESSION_FILE)
            print("‚úÖ Session saved")

        # GO TO tele_build page
        await page.goto(f"{args.url}/?function=tele_build")
        await page.wait_for_load_state('networkidle')

        # CLICK ON WINDOWS
        await page.click('text=Windows')
        await page.wait_for_load_state('networkidle')

        # CLICK ON OTHERS
        await page.click('text=OTHERS')
        await page.wait_for_load_state('networkidle')

        # CLICK ON CUSTOM
        await page.click('text=Custom')
        await page.wait_for_load_state('networkidle')

        # GET THE CSRF TOKEN ONLY FROM THE CUSTOM FORM
        form_custom = page.locator("form").filter(has=page.locator('input[name="NAME"]'))
        csrf_elem = form_custom.locator('input[name^="CSRF_"]').first
        csrf_name = await csrf_elem.get_attribute("name")
        csrf_value = await csrf_elem.get_attribute("value")
        print(f"üîë CSRF retrieved: {csrf_name} = {csrf_value}")

        # FILL OUT THE FORM
        # Wait until the NAME field appears
        await page.wait_for_selector('input[name="NAME"]', timeout=10000)
        await page.fill('input[name="NAME"]', args.name)
        await page.fill('input[name="DESCRIPTION"]', args.description)
        await page.select_option('select[name="PROTO"]', 'HTTP')
        await page.select_option('select[name="PRI"]', str(args.priority))
        await page.select_option('select[name="ACT"]', 'EXECUTE')
        await page.fill('input[name="pathfile"]', 'install.bat')
        # File upload
        await page.set_input_files('input[name="additionalfiles"]', args.file)
        # Notification
        await page.select_option('select[name="NOTIFY_USER"]', args.notify)
        if args.notify == 'YES':
            await page.fill('input[name="NOTIFY_TEXT"]', args.notif_text)
            await page.fill('input[name="NOTIFY_COUNTDOWN"]', str(args.notif_duration))
            await page.select_option('select[name="NOTIFY_CAN_DELAY"]', args.can_report)
            await page.select_option('select[name="NOTIFY_CAN_ABORT"]', args.can_cancel)
        await capture(page, "tmp_package_submission1.png")

        # SUBMIT
        await page.locator('input[type="submit"]').scroll_into_view_if_needed()
        await capture(page, "tmp_package_submission2.png")
        try:
            await page.click('input[type="submit"]', timeout=args.timeout * 1000)
            # Check that the package is present
            await page.wait_for_selector(f'text="{args.name}"', timeout=args.timeout * 1000)
            print(f"üì¶ Package successfully submitted: {args.name}")
            # Confirmation capture
            await capture(page, "tmp_package_submit_result.png")

            #async with page.expect_navigation(timeout=args.timeout * 1000):
            #   await page.locator('input[type="submit"]').click(timeout=args.timeout * 1000) 
            ## After browsing, check that the package is present
            #if await page.locator(f"text={args.name}").first.is_visible():
            #    print(f"üì¶ Package successfully submitted: {args.name}")
            #    # Confirmation capture
            #    await capture(page, "tmp_package_submit_result.png")
            #else:
            #    print(f"‚ùå Package '{args.name}' not found in the server response!")
            #    await browser.close()
            #    sys.exit(1)

        except PlaywrightTimeoutError:
            print("‚è≥ Timeout exceeded during file upload (no package name found).")
            print(f"‚ùå Package failed: {args.name}")
            await browser.close()
            sys.exit(1)

        except PlaywrightError as e:
            print(f"‚ö†Ô∏è Playwright error during submission: {e}")
            print(f"‚ùå Package failed: {args.name}")
            await browser.close()
            sys.exit(1)

        await browser.close()

asyncio.run(main())
END_PYTHON
